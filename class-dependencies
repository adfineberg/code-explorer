#!/usr/bin/ruby

# class dependency graph

require "parser/current"
require "pp"
require "set"

def main
  filename_rb = ARGV[0]
  ast = ast_for_filename(filename_rb)
  dot = dep_graph(ast)
  filename_dot = filename_rb.sub(/\.rb$/, "") + ".class.dot"
  File.write(filename_dot, dot)
end

def dot_from_hash(graph)
  dot = ""
  dot << "digraph g {\n"
  dot << "rankdir=LR;\n"
  graph.keys.sort.each do |vertex|
    destinations = graph[vertex].sort
    dot << "\"#{vertex}\"[href=\"/#{vertex}\"];\n"
    destinations.each do |d|
      dot << "\"#{vertex}\" -> \"#{d}\";\n"
    end
  end
  dot << "}\n"
  dot
end

def ast_for_filename(fn)
  ruby = File.read(fn)
  Parser::CurrentRuby.parse(ruby)
end

# ruby [String] a ruby program
# @return a dot graph string
def dep_graph(ast)
  Consts.new.report_modules(ast)
  dot_from_hash({})
end

# tracks what constants are resolvable
class ConstBinding
  def initialize(fqname, parent = nil)
    @fqname = fqname
    @parent = parent
    @known = Set.new
  end

  # @return [ConstBinding] the new scope
  def open_namespace(fqname)
    ns = self.class.new(fqname, self)
    @known << fqname
    ns
  end

  # @return [ConstBinding] the parent scope
  def close_namespace
    @parent
  end

  def resolve_declared_const(name)
    if @fqname.empty?
      name
    else
      "#{@fqname}::#{name}"
    end
  end

  def resolve_used_const(name)
#    puts "resolving #{name} in #{@fqname}, known #{@known.inspect}"
    candidate = resolve_declared_const(name)
    if @known.include?(candidate)
      candidate
    else
      name
    end
  end
end

class Consts < Parser::AST::Processor
  # @return [ConstBinding]
  attr_reader :cb

  def initialize
    @cb = ConstBinding.new("")
  end

  def report_modules(ast)
    process(ast)
  end

  def const_name_from_sexp(node)
    case node.type
    when :self
      "self"
    when :cbase
      ""
    when :const
      parent, name = *node
      if parent
        const_name_from_sexp(parent) + "::#{name}"
      else
        name.to_s
      end
    else
      raise "Unexpected #{node.type}"
    end
  end

  def new_scope(name, &block)
    @cb = cb.open_namespace(name)
    block.call
    @cb = cb.close_namespace
  end

  def on_module(node)
    name, _body = *node
    name = cb.resolve_declared_const(const_name_from_sexp(name))
    puts "module #{name}"

    new_scope(name) do
      super
    end
  end

  def on_class(node)
    name, parent, _body = *node
    parent ||= AST::Node.new(:const, [nil, :Object]) # or ::Object?

    name   = cb.resolve_declared_const(const_name_from_sexp(name))
    parent = cb.resolve_used_const(const_name_from_sexp(parent))
    puts "class #{name} < #{parent}"

    new_scope(name) do
      super
    end
  end

  def on_sclass(node)
    parent, _body = *node

    parent = const_name_from_sexp(parent)
    name = "<< #{parent}" # cheating
    puts "class #{name}"

    new_scope(name) do
      super
    end
  end
end

main
