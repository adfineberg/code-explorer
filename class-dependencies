#!/usr/bin/ruby

# class dependency graph

require "parser/current"
require "pp"

def main
  filename_rb = ARGV[0]
  ast = ast_for_filename(filename_rb)
  dot = dep_graph(ast)
  filename_dot = filename_rb.sub(/\.rb$/, "") + ".class.dot"
  File.write(filename_dot, dot)
end

def dot_from_hash(graph)
  dot = ""
  dot << "digraph g {\n"
  dot << "rankdir=LR;\n"
  graph.keys.sort.each do |vertex|
    destinations = graph[vertex].sort
    dot << "\"#{vertex}\"[href=\"/#{vertex}\"];\n"
    destinations.each do |d|
      dot << "\"#{vertex}\" -> \"#{d}\";\n"
    end
  end
  dot << "}\n"
  dot
end

def ast_for_filename(fn)
  ruby = File.read(fn)
  Parser::CurrentRuby.parse(ruby)
end

# ruby [String] a ruby program
# @return a dot graph string
def dep_graph(ast)
  Consts.new.report_modules(ast)
  dot_from_hash({})
end

def def_name(node)
  name, _args, _body = *node
  name
end

def send_name(node)
  _receiver, name, *_args = *node
  name
end

class Consts < Parser::AST::Processor
  def initialize
  end

  def report_modules(ast)
    @module_nesting = []
    process(ast)
  end

  def const_name_from_sexp(node)
    case node.type
    when :self
      "self"
    when :cbase
      ""
    when :const
      parent, name = *node
      if parent
        const_name_from_sexp(parent) + "::#{name}"
      else
        name.to_s
      end
    else
      raise "Unexpected #{node.type}"
    end
  end

  def on_module(node)
    name, _body = *node
    name = const_name_from_sexp(name)
    puts "module #{name}"
    super
  end

  def on_class(node)
    name, parent, _body = *node
    parent ||= AST::Node.new(:const, [nil, :Object])

    name   = const_name_from_sexp(name)
    parent = const_name_from_sexp(parent)
    puts "class #{name} < #{parent}"
    super
  end

  def on_sclass(node)
    parent, _body = *node

    parent = const_name_from_sexp(parent)
    puts "class << #{parent}"
    super
  end
end


main
