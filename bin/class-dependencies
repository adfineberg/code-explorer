#!/usr/bin/ruby

# class dependency graph

require "parser/current"
require "pp"

$: << File.expand_path("../lib", __FILE__)
require "dot"

def main
  asts = ARGV.map {|fn| ast_for_filename(fn)}
  cs = Consts.new
  cs.report_modules(asts)
  graph = cs.superclasses
  puts dot_from_hash(graph)
end

def ast_for_filename(fn)
  ruby = File.read(fn)
  Parser::CurrentRuby.parse(ruby)
end

# ruby [String] a ruby program
# @return a dot graph string
def dep_graph(ast)
  Consts.new.report_modules(ast)
  dot_from_hash({})
end

# tracks what constants are resolvable
class ConstBinding
  def initialize(fqname, parent = nil)
    @fqname = fqname
    @parent = parent
    @known = {}
  end

  # @return [ConstBinding] the new scope
  def open_namespace(fqname)
    ns = @known[fqname]
    if ns.is_a? ConstBinding
      # puts "(reopening #{fqname})"
    else
      ns = self.class.new(fqname, self)
      @known[fqname] = ns
    end
    ns
  end

  # @return [ConstBinding] the parent scope
  def close_namespace
    @parent
  end

  def declare_const(fqname)
    if @known[fqname]
#      puts "warning: #{fqname} already declared"
    end
    @known[fqname] = :const
  end

  def resolve_declared_const(name)
    if @fqname.empty?
      name
    else
      "#{@fqname}::#{name}"
    end
  end

  def resolve_used_const(name)
#    puts "resolving #{name} in #{@fqname}, known #{@known.inspect}"
    candidate = resolve_declared_const(name)
    if @known.include?(candidate)
      candidate
    elsif @parent
      @parent.resolve_used_const(name)
    else
      name
    end
  end
end

class Consts < Parser::AST::Processor
  include AST::Sexp

  # @return [ConstBinding]
  attr_reader :cb
  # @return [Hash{String => Array<String>}]
  attr_reader :superclasses

  def initialize
    @cb = ConstBinding.new("")
    @superclasses = {}
  end

  def report_modules(asts)
    Array(asts).each do |ast|
      process(ast)
    end
  end

  def const_name_from_sexp(node)
    case node.type
    when :self
      "self"
    when :cbase
      ""
    when :const, :casgn
      parent, name, _maybe_value = *node
      if parent
        const_name_from_sexp(parent) + "::#{name}"
      else
        name.to_s
      end
    else
      raise "Unexpected #{node.type}"
    end
  end

  def new_scope(name, &block)
    @cb = cb.open_namespace(name)
    block.call
    @cb = cb.close_namespace
  end

  def on_module(node)
    name, _body = *node
    name = cb.resolve_declared_const(const_name_from_sexp(name))
#    puts "module #{name}"

    new_scope(name) do
      super
    end
  end

  def on_class(node)
    name, parent, _body = *node
    parent ||= s(:const, s(:cbase), :Object)

    name   = cb.resolve_declared_const(const_name_from_sexp(name))
    parent = cb.resolve_used_const(const_name_from_sexp(parent))
#    puts "class #{name} < #{parent}"

    @superclasses[name] = [parent]

    new_scope(name) do
      super
    end
  end

  def on_sclass(node)
    parent, _body = *node

    parent = const_name_from_sexp(parent)
    name = "<< #{parent}" # cheating
#    puts "class #{name}"

    new_scope(name) do
      super
    end
  end

  def on_casgn(node)
    name = cb.resolve_declared_const(const_name_from_sexp(node))
    cb.declare_const(name)
#    puts "casgn #{name}"
  end

  def on_const(node)
    name = const_name_from_sexp(node)
    fqname = cb.resolve_used_const(name)
#    puts "CONST #{fqname}"
  end

end

main
